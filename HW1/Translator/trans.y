%define parse.trace
%define parse.error detailed
%{
#include <iostream>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <cstddef>
#include "treenode.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };

using namespace asttree;
%}

%union {
   treenode* val;
};

%start prog
%token <val> TERM_OR_NONTERM REWRITES SEMI REP_ZERO_LEFT REP_ZERO_RIGHT ENDL SECTION
%token <val> OPTION_LEFT OPTION_RIGHT
%token <val> GROUPING_LEFT GROUPING_RIGHT GROUP_OR
%token <val> RULE_OR
%token <val> REP_ONE REP_ZERO

%type <val> prog statements statement one_or_more

%%

prog : SECTION statements SECTION   {  $$ = new prog($1,$2,$3);  /* This adds a node to our own parse tree */
                                    //    $$->doConversion();
                                        cout << "=================This is the final output==================";
                                       $$->print(cout);
                                       cout << "===================End of output========================";
                                    } 
    ;

statements :  statement statements          {  $$ = new statements($1, $2);  /* This adds a node to our own parse tree */
                                            BNFConverter::statementNode = $$; 
                                            }
    |         statement RULE_OR statements  {  $$ = new statements($1, $2, $3);  /* This adds a node to our own parse tree */ }
    |         statement SEMI statements     {  $$ = new statements($1, $2, $3); }
    |         statement SEMI                {  $$ = new statements($1, $2); }
    ;

statement :  TERM_OR_NONTERM REWRITES statement  {  $$ = new statement($1, $2, $3); }
    |        TERM_OR_NONTERM statement           {  $$ = new statement($1, $2); /* This adds a node to our own parse tree */ }
    |        TERM_OR_NONTERM GROUP_OR statement  {  $$ = new statement($1, $2, $3); }
    |        ENDL                                {  $$ = new terminal(""); }
    |        GROUPING_LEFT statement GROUPING_RIGHT {  $$ = new statement($1); }
    |        statement one_or_more REP_ONE       {  $$ = new statement($1, $2, $3)}
    |        %empty
    ;

one_or_more : TERM_OR_NONTERM one_or_more               {  $$ = new statement($1)}


 /* Fill in any other rules here */


%%

int main()
{
    yydebug = 1;
    yyparse(); // A parsing function that will be generated by Bison.

    return 0;
}
