%{
#include <iostream>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <cstddef>
#include "treenode.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };

using namespace asttree;
%}

%union {
   treenode* val;
};

%start prog
%token <val> TERM_OR_NONTERM REWRITES SEMI REP_ZERO_LEFT REP_ZERO_RIGHT ENDL SECTION
%token <val> OPTION_LEFT OPTION_RIGHT
%token <val> GROUPING_LEFT GROUPING_RIGHT GROUP_OR
%token <val> RULE_OR
%token <val> REP_ONE REP_ZERO

%type <val> prog statements statement expr quant rest 

%%

prog : SECTION statements SECTION   {  $$ = new prog($1,$2,$3);  /* This adds a node to our own parse tree */
                                       $$->doConversion();
                                       $$->print(cout);
                                    } 
    ;

statements :  statement             {
                                       $$ = new statements($1);  /* This adds a node to our own parse tree */
                                       BNFConverter::statementNode = $$; 
                                    }

    |    statement statements       {  $$ = new statements($1, $2);  /* This adds a node to our own parse tree */ }
    ;

statement : /* Fill in the rest of the rule */   {   $$ = new statement($1,$2,$3,...); /* This adds a node to our own parse tree */ }
    ;

expr :  /* Fill in the rest of the rule  */
    ;


 /* Fill in any other rules here */


%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.

    return 0;
}
